package pl.iterators.baklava.formatteropenapi

import io.swagger.v3.core.util.Yaml
import io.swagger.v3.oas.models._
import io.swagger.v3.oas.models.examples.Example
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.media._
import io.swagger.v3.oas.models.parameters.{Parameter, RequestBody}
import io.swagger.v3.oas.models.responses.{ApiResponse, ApiResponses}
import pl.iterators.baklava.core.formatters.Formatter
import pl.iterators.baklava.core.model.EnrichedRouteRepresentation
import pl.iterators.kebs.jsonschema.JsonSchemaWrapper

import java.io.{File, FileWriter, PrintWriter}
import scala.collection.JavaConverters._
import scala.util.Try

class OpenApiFormatter extends Formatter {

  override def generate(
      outputPath: String,
      routesList: List[EnrichedRouteRepresentation[_, _]]): Unit = {
    val dir = new File(outputPath)
    Try(dir.mkdirs())

    val fileWriter = new FileWriter(s"$outputPath/openapi.yml")
    val printWriter = new PrintWriter(fileWriter)

    printWriter.print(
      Yaml.pretty().writeValueAsString(generateOpenApi(routesList)))
    printWriter.close()
    fileWriter.close()
  }

  private def generateOpenApi(
      routesList: List[EnrichedRouteRepresentation[_, _]]): OpenAPI = {
    val openApi = new OpenAPI

    openApi.setInfo(new Info().title("Autogenerated API doc").version("1"))

    val paths = new Paths()
    routesList.groupBy(_.routeRepresentation.path).toList.sortBy(_._1).map {
      case (path, routes) =>
        val pathItem = new PathItem()

        routes
          .find(_.routeRepresentation.method == "GET")
          .foreach(r => pathItem.setGet(routeToOperation(r)))
        routes
          .find(_.routeRepresentation.method == "POST")
          .foreach(r => pathItem.setPost(routeToOperation(r)))
        routes
          .find(_.routeRepresentation.method == "PATCH")
          .foreach(r => pathItem.setPatch(routeToOperation(r)))
        routes
          .find(_.routeRepresentation.method == "PUT")
          .foreach(r => pathItem.setPut(routeToOperation(r)))
        routes
          .find(_.routeRepresentation.method == "DELETE")
          .foreach(r => pathItem.setDelete(routeToOperation(r)))

        val pattern = """\{(.*?)\}""".r
        pattern.findAllMatchIn(path).toList.map { m =>
          val p = new Parameter()
          p.setName(m.group(1))
          p.setIn("path")
          p.setSchema(new StringSchema)
          pathItem.addParametersItem(p)
        }

        paths.addPathItem(path, pathItem)
    }
    openApi.setPaths(paths)

    val components = new Components()
    routesList
      .map(_.routeRepresentation)
      .filter(_.request.scalaClassOpt.isDefined)
      .map { r =>
        components.addSchemas(schemaClassName(r.request.scalaClassOpt.get),
                              swaggerSchema(r.requestJsonSchemaWrapper))
      }
    routesList
      .map(_.routeRepresentation)
      .filter(_.response.scalaClassOpt.isDefined)
      .map { r =>
        components.addSchemas(schemaClassName(r.response.scalaClassOpt.get),
                              swaggerSchema(r.responseJsonSchemaWrapper))
      }
    openApi.setComponents(components)

    openApi
  }

  private def routeToOperation[Req, Res](
      route: EnrichedRouteRepresentation[Req, Res]): Operation = {
    val operation = new Operation()
    operation.setSummary(route.routeRepresentation.description)
    operation.setDescription(
      route.enrichDescriptions.map(_.description).mkString("\n"))

    route.routeRepresentation.parameters.foreach { param =>
      val p = new Parameter()
      p.setName(param.name)
      p.setIn("query")
      p.setExample(param.sampleValue)
      p.setRequired(param.required)
      p.setSchema(new StringSchema)
      operation.addParametersItem(p)
    }

    route.routeRepresentation.headers.foreach { header =>
      val p = new Parameter()
      p.setName(header.name)
      p.setIn("header")
      p.setRequired(header.required)
      p.setSchema(new StringSchema)
      operation.addParametersItem(p)
    }

    route.routeRepresentation.request.minimal.jsonOpt.foreach { _ =>
      val apiRequest = new RequestBody()
      val mt = new MediaType

      route.routeRepresentation.request.minimal.jsonOpt.foreach { json =>
        val example = new Example()
        example.setValue(json.prettyPrint)
        mt.addExamples("minimal", example)

        val schema = new Schema
        schema.setType(
          swaggerSchemaHelper(
            route.routeRepresentation.requestJsonSchemaWrapper.schema).getType)
        schema.set$ref(
          schemaRefName(route.routeRepresentation.request.scalaClassOpt.get))
        mt.setSchema(schema)
      }

      route.routeRepresentation.request.maximal.jsonOpt.foreach { json =>
        val example = new Example()
        example.setValue(json.prettyPrint)
        mt.addExamples("maximal", example)
      }

      apiRequest.setRequired(true)
      apiRequest.setContent(new Content().addMediaType("application/json", mt))
      operation.requestBody(apiRequest)
    }

    val apiResponses = new ApiResponses()
    route.enrichDescriptions
      .groupBy(_.statusCodeOpt)
      .filter(_._1.isDefined)
      .toList
      .sortBy(_._1.map(_.intValue()))
      .foreach {
        case (codeOpt, desc) =>
          val code = codeOpt.get //get is safe here
          val apiResponse = new ApiResponse()

          apiResponse.setDescription(desc.map(_.description).mkString("\n"))
          if (code.intValue >= 200 && code.intValue < 204) {
            val mt = new MediaType

            route.routeRepresentation.response.minimal.jsonOpt.foreach { json =>
              val example = new Example()
              example.setValue(json.prettyPrint)
              mt.addExamples("minimal", example)

              val schema = new Schema
              schema.setType(swaggerSchemaHelper(
                route.routeRepresentation.responseJsonSchemaWrapper.schema).getType)
              schema.set$ref(
                schemaRefName(
                  route.routeRepresentation.response.scalaClassOpt.get))
              mt.setSchema(schema)
            }

            route.routeRepresentation.response.maximal.jsonOpt.foreach { json =>
              val example = new Example()
              example.setValue(json.prettyPrint)
              mt.addExamples("maximal", example)
            }

            apiResponse.setContent(
              new Content().addMediaType("application/json", mt))
          }

          apiResponses.addApiResponse(code.intValue.toString, apiResponse)
      }
    operation.setResponses(apiResponses)

    operation
  }

  private def swaggerSchema[T](jsonSchema: JsonSchemaWrapper[T]): Schema[_] = {
    swaggerSchemaHelper(jsonSchema.schema)
  }

  private def swaggerSchemaHelper(jsonSchema: json.Schema[_]): Schema[_] = {
    jsonSchema.jsonType match {
      case "null" =>
        ???
      case "boolean" =>
        new BooleanSchema
      case "number" =>
        new NumberSchema
      case "integer" =>
        new NumberSchema
      case "string" =>
        val schema = new StringSchema

        val s = jsonSchema.asInstanceOf[json.Schema.`string`[AnyRef]]

        s.format.foreach { format =>
          schema.setFormat(format.toString)
        }

        schema
      case "enum" =>
        val schema = new StringSchema
        val s = jsonSchema.asInstanceOf[json.Schema.`enum`[AnyRef]]

        schema.setEnum(s.values.map(_.toString).toList.asJava)
        schema
      case "array" =>
        val schema = new ArraySchema

        val s = jsonSchema.asInstanceOf[json.Schema.array[AnyRef, json.Schema]]

        schema.setItems(swaggerSchemaHelper(s.componentType))

        schema

      case "object" =>
        if (jsonSchema.toString.startsWith("dictionary")) {
          val schema = new ObjectSchema
          val s =
            jsonSchema.asInstanceOf[json.Schema.dictionary[AnyRef, AnyRef, Map]]

          schema.addProperties("^.*$", swaggerSchemaHelper(s.valueType))
          schema
        } else {
          val schema = new ObjectSchema
          val s = jsonSchema.asInstanceOf[json.Schema.`object`[AnyRef]]

          s.fields.foreach { f =>
            schema.addProperties(f.name, swaggerSchemaHelper(f.tpe))
          }
          schema.setRequired(
            s.fields.filter(_.required).map(_.name).toList.asJava)
          schema
        }
    }
  }

  private def schemaRefName(name: String): String =
    s"#/components/schemas/${schemaClassName(name)}"

  private def schemaClassName(name: String): String =
    name.replaceAll("\\[", "_").replaceAll("\\]", "")
}
